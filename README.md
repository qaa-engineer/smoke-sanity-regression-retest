# Чем отличаются тесты Smoke, Sanity, Regression, Re-test

<div>
<br>
<h2>О чём это всё</h2><br>
Будучи инженером по тестированию, вы, вероятно, слышали о таких видах тестирования как «дымовое» (smoke), «санитарное тестирование» (sanity), «ре-тест» и регрессионное тестирование. Вполне возможно, многие из этих видов используются вами на ежедневной основе. <br>
<br>
В этой статье я хотел бы внести ясность и объяснить разницу между этими видами тестирования и попробовать разобраться, провести границы (хоть и условные) где заканчивается один вид тестирования, и начинается другой.<br>
<a name="habracut"></a><br>
Для новичков в тестировании (и даже опытных тестировщиков) разделение этих понятий может быть затруднительно. И в самом деле, как отличить где начинается санити-тестирование и заканчивается smoke? Насколько сильно нам надо ограничить проверку части функциональности системы или её компонентов, чтобы назвать это «дымовым» тестированием? Является ли ввод логина/пароля в пользовательскую форму входа на сайт дымовым тестом, или сам факт её появления на странице сайта уже является пройденным тестом? <br>
<br>
Строго говоря, вы всё равно сможете проводить тестирование, даже при том что не сможете точно сказать, в чём же разница. Можно даже не задумываться о разграничении, каким именно видом тестирования вы сейчас заняты. Но всё же, чтобы расти над собой в профессиональном смысле, нужно знать что вы делаете, зачем, и насколько правильно вы это делаете.<br>
<br>
<h2>Ликбез</h2><br>
Ниже приведены краткие определения видов тестирования, которые мы сегодня сравниваем:<br>
<br>
<ul>
<li> <b>Дымовые тесты</b>: выполняются каждый раз, когда мы получаем новый билд (версию), проекта (системы) на тестирование, при этом считая её относительно нестабильной. Нам нужно убедиться что критически важные функции AUT (Application Under Test) работают согласно ожиданиям. Идея данного вида тестирования заключается в том, чтобы выявить серьёзные проблемы как можно раньше, и отклонить этот билд (вернуть на доработку) на раннем этапе тестирования, чтобы не углубляться в долгие и сложные тесты, не затрачивая тем самым время на заведомо бракованное ПО. </li>
<li> <b>Санитарное тестирование</b>: используется каждый раз, когда мы получаем относительно стабильный билд ПО, чтобы определить работоспособность в деталях. Иными словами, здесь проходит валидация того, что важные части функциональности системы работают согласно требованиям на низком уровне. </li>
</ul><br>
Оба эти вида тестирования нацелены на то, чтобы избежать потерь времени и усилий, чтобы быстрее определить недостатки ПО и их критичность, а так же то, заслуживает ли оно перехода в фазу более углублённого и тщательного тестирования или же нет.<br>
<br>
<ul>
<li> <b>Ре-тест</b>: проводится в случае, если фича/функциональность уже имела дефекты, и эти дефекты были недавно исправлены </li>
<li> <b>Регрессионные тесты</b>: собственно то, что занимает львиную долю времени и для чего существует автоматизация тестирования. Проводится регрессионное тестирование AUT тогда, когда нужно убедиться что новые (добавленные) функции приложения / исправленные дефекты не оказали влияния на текущую, уже существующую функциональность, работавшую (и протестированную) ранее. </li>
</ul><br>
Для лучшего понимания ниже представлена сравнительная таблица этих понятий и области применения:<br>
<div class="table table_wrapped"><table>
<tbody><tr>
<th>Дымовые (Smoke)</th>
<th>Санити (Sanity)</th>
<th>Регрессионные (Regression)</th>
<th>Ре-тест (Re-test)</th>
</tr>
<tr>
<td>Исполняются с целью проверить что критически важные функциональные части AUT работают как положено</td>
<td>Нацелено на установление факта того, что определённые части AUT всё так же работают как положено после минорных изменений или исправлений багов</td>
<td>Подтверждают, что свежие изменения в коде или приложении в целом не оказали негативного влияния на уже существующую функциональность/набор функций</td>
<td>Перепроверяет и подтверждает факт того, что ранее заваленные тест-кейсы проходят после того, как дефекты исправлены</td>
</tr>
<tr>
<td>Цель — проверить «стабильность» системы в целом, чтобы дать зелёный свет проведению более тщательного тестирования</td>
<td>Целью является проверить общее состояние системы в деталях, чтобы приступить к более тщательному тестированию</td>
<td>Цель — убедиться что свежие изменения в коде не оказали побочных эффектов на устоявшуюся работающую функциональность</td>
<td>Ре-тест проверяет что дефект исправлен</td>
</tr>
<tr>
<td>Перепроверка дефектов не является целью Smoke</td>
<td>Перепроверка дефектов не является целью Sanity</td>
<td>Перепроверка дефектов не является целью Regression</td>
<td>Факт того что дефект исправлен подтверждает Re-Test</td>
</tr>
<tr>
<td>Дымовое тестирование выполняется <b>перед</b> регрессионным</td>
<td>Санитарное тестирование выполняется <b>перед</b> регрессионным и <b>после</b> smoke-тестов</td>
<td>Проводится на основании требований проекта и доступности ресурсов (закрывается автотестами), «регресс» может проводиться в параллели с ре-тестами</td>
<td> — Ре-тест выполняется перед sanity-тестированием<br>
 — Так же, приоритет ре-теста выше регрессионных проверок, поэтому должно выполняться перед ними</td>
</tr>
<tr>
<td>Может выполняться автоматизированно или вручную</td>
<td>Чаще выполняется вручную</td>
<td>Лучший повод для автоматизации данного вида тестирования, т.к. ручное может быть крайне затратным по ресурсам или времени</td>
<td>Не поддаётся автоматизации</td>
</tr>
<tr>
<td>Является подмножеством регрессионного тестирования</td>
<td>Подмножество приёмочного тестирования</td>
<td>Выполняется при любой модификации или изменениях в уже существующем проекте</td>
<td>Ре-тест проводится на исправленной сборке с использованием тех же данных, на том же окружении, но с различным набором входных данных</td>
</tr>
<tr>
<td>Тест-кейсы часть регрессионных тест-кейсов, но покрывающие крайне критичную функциональность</td>
<td>Санитарное может выполняться без тест-кейсов, но знание тестируемой системы обязательно</td>
<td>Тест-кейсы регрессионного тестирования могут быть получены из функциональных требований или спецификаций, пользовательских мануалов, и проводятся вне зависимости от того, что исправили разработчики</td>
<td>Используется тот же самый тест-кейс, который выявил дефект</td>
</tr>
</tbody></table></div><br>
<h2>Ну а по существу?</h2><br>
Приведу пример разграничения понятий на моём текущем проекте.<br>
<br>
Пример: у нас есть веб-сервис с пользовательским интерфейсом и RESTful API. Будучи тестировщиками, мы знаем:<br>
<br>
<ul>
<li>Что у него есть 10 точек входа, для простоты, в нашем случае расположенных на одном IP</li>
<li>Мы знаем все они принимают GET-запрос на вход, возвращая какие-либо данные в формате json.</li>
</ul><br>
Тогда можно сделать ряд утверждений о том, какие типы тестов нужно использовать в какой момент времени:<br>
<ul>
<li>Выполнив один простой GET-запрос к одной из этих точек входа, и получив ответ в формате json, мы уже убеждаемся что дымное тестирование пройдено.<br>
Если же одна из этих точек входа так же возвращает данные из БД, тогда как первая — нет, нужно дополнительно выполнить ещё один запрос, чтобы убедиться что приложение<br>
верно обрабатывает запросы к базе. И на этом «дымный» тест закончен. <br>
<br>
То есть мы выполнили запрос — от сервиса пришёл ответ, и он не «задымился», то есть не вернул ошибку 4хх или 5хх, и что-то невнятное, вместо json. На этом можно сказать что «дымный» тест пройден. Для проверки того, что работает так же и UI достаточно просто один раз открыть страницу в браузере.</li>
<li>Санитарное тестирование в данном случае будет состоять из выполнения запроса ко всем 10 точкам входа в api, сверкой полученного json с ожидаемым, а так же наличием требуемых данных в нём.</li>
<li>Регрессионные тесты будут состоять из smoke + sanity + UI выполняемые вместе в одной куче. Цель: проверить что добавление 11-ой точки входа не поломало, к примеру, восстановление пароля.</li>
<li>Ре-тест в данном примере это точечная проверка что, к примеру, сломавшаяся точка входа в api в следующем билде отрабатывает как задумывалось.</li>
</ul><br>
При этом, если это api принимает так же post-запросы, то очевидно что в другой набор тестов sanity нужно включить именно эти запросы. По аналогии с UI мы будем проверять все страницы приложения.<br>
<br>
<h2>Подведём итог</h2><br>
Надеюсь, что после чтения данной статьи, у вас появится ясность в определении какой вид тестирования вы используете на каком этапе, и в чём разница между этими видами тестирования. Как и было упомянуто вначале, граница между этими понятиями весьма условная и остаётся на ваше усмотрение в рамках проекта.<br>
<br>
</div>
